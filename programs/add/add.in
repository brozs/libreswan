#!@PYTHON_BINARY@
#
""" command to create IPsec connection configuration files """
#
# Copyright (C) 2021       Stepan Broz <sbroz@redhat.com>
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.  See <https://www.gnu.org/licenses/gpl2.txt>.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
# or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# for more details.
#

import os
import sys
import socket
import argparse
import inspect
import re

try:
    import ipaddress
except ImportError:
    sys.exit("This program requires the python ipaddress module from \
             https://pypi.python.org/pypi/ipaddress")

# The drop-in directory for connection configurations, e.g. /etc/ipsec.d
CONFDIR = "@IPSEC_CONFDDIR@"

# For testing XXX
# CONFDIR = "/etc/ipsec.d"

def print_debug(debug, name, lineno, text):
    """ Print debug information """
    if debug:
        print(os.path.basename(inspect.currentframe().f_code.co_filename)
            + ':' + str(lineno) + ': in ' + name
            + ': ' + text)

def fatal_error(text):
    """ Print error and exit with a failure status """
    print('ERROR: ' + text)
    sys.exit(1)

def user_prompt(text):
    """ Prompt the user for confirmation

        text    what is displayed on screen as a question for the prompt

        Boolean. Returns True if used confirmed, False otherwise.
    """
    # TBD XXX
    return True

def is_magic(text):
    """ Check if the string is a magic word

        text        the string to check

        Boolean. It simply verifies that 'text' starts with '%'.
    """

    return bool(re.match('^%',text))

def write_config(name, my_config):
    """ Write the connection configuration file

        name        absolute path to the configuration file
        my_config   program configuration dictionary
    """

    debug = my_config['debug']
    prompt = my_config['prompt']
    assume_yes = my_config['assume_yes']

    print_debug(debug, inspect.currentframe().f_code.co_name,
        inspect.currentframe().f_lineno,
        'entered')

    fname = name.strip()

    try:
        conf_file = open(fname, "x")
    except FileExistsError:
        if (assume_yes or
            (prompt and user_prompt('File "' + fname + '" already exists. ' +
                                  'Overwrite?'))):
            print_debug(debug, inspect.currentframe().f_code.co_name,
            inspect.currentframe().f_lineno,
            'Overwriting "' + fname + '".')
            try:
                conf_file = open(fname, "w")
            except (OSError, IOError) as fexcept:
                fatal_error('Error while opening ' + fname + ' for writing: '
                + str(os.strerror(fexcept.errno)))

        else:
            fatal_error('File "' + fname + '" already exists, aborting.')

    except (OSError, IOError) as fexcept:
        fatal_error('Error while opening ' + fname + ' for writing: '
        + str(os.strerror(fexcept.errno)))

    conf_file.close()

    print_debug(debug, inspect.currentframe().f_code.co_name,
        inspect.currentframe().f_lineno,
        'leaving')



def get_peer_confstring(peer, my_config):
    """ Validates and prepares the left=/right= string value based on the
        supplied "peer" string

        peer        string given by the user
        my_config   program configuration dictionary

        Raises ValueError if all checks fail, e.g. hostname does not DNS
        resolve, invalid IP address format, etc.
    """

    debug = my_config['debug']
    use_dns = my_config['dns']
    prompt = my_config['prompt']
    assume_yes = my_config['assume_yes']

    print_debug(debug, inspect.currentframe().f_code.co_name,
        inspect.currentframe().f_lineno,
        'entered')

    # Check magic words XXX
    if is_magic(peer):
        print_debug(debug, inspect.currentframe().f_code.co_name,
            inspect.currentframe().f_lineno,
            '"' + peer + '"' + ' appears to be a magic word, leaving')
        return peer

    # No magic, continue
    print_debug(debug, inspect.currentframe().f_code.co_name,
        inspect.currentframe().f_lineno,
        '"' + peer + '"' + ' is NOT a magic word')

    try:
        peer_ip = ipaddress.ip_address(peer)
    except ValueError:
        print_debug(debug, inspect.currentframe().f_code.co_name,
            inspect.currentframe().f_lineno,
            '"' + peer + '"' + ' appears NOT to be an IP address')

        try:
            peer_ip = ipaddress.ip_network(peer)
        except ValueError:
            print_debug(debug, inspect.currentframe().f_code.co_name,
                inspect.currentframe().f_lineno,
                '"' + peer + '"' + ' appears NOT to be an IP network')

            try:
                peer_ip = ipaddress.ip_network(peer, strict=False)
            except ValueError:
                print_debug(debug, inspect.currentframe().f_code.co_name,
                    inspect.currentframe().f_lineno,
                    '"' + peer + '"' + ' appears NOT to be an IP network' +
                    ' with host bits set')

                if use_dns:
                    try:
                        data = socket.getaddrinfo(peer, port=None)
                    except socket.gaierror:
                        print_debug(debug,
                            inspect.currentframe().f_code.co_name,
                            inspect.currentframe().f_lineno,
                            '"' + peer + '"' + ' does NOT resolve')
                        # Dooomed. Fallthrough.

                    else:
                        print_debug(debug,
                            inspect.currentframe().f_code.co_name,
                            inspect.currentframe().f_lineno,
                            '"' + peer + '"' + ' resolved OK to: ' +
                            str(data) + ', leaving')
                        return peer

                else:
                    print_debug(debug,
                            inspect.currentframe().f_code.co_name,
                            inspect.currentframe().f_lineno,
                            '--nodns present, skipping DNS checks. ' +
                            'Using "' + peer + '"and leaving')
                    # Check for valid hostname string XXX
                    return peer

            else:
                err_string = '"' + str(peer) + '"' + ' appears to be an '
                err_string += 'IP network with some host bits set. '

                print_debug(debug, inspect.currentframe().f_code.co_name,
                    inspect.currentframe().f_lineno, err_string)

                if (assume_yes or
                    (prompt and user_prompt(err_string +
                        '"' + str(peer) + '" ' +
                        'appears to be an IP network with host bits ' +
                        'set, use "' + str(peer_ip) + ': instead?'))):

                    print_debug(debug, inspect.currentframe().f_code.co_name,
                        inspect.currentframe().f_lineno,
                        'Using "' + str(peer_ip) + '" and leaving')
                    return str(peer_ip)

                # else, Fallthrough

        else:
            print_debug(debug, inspect.currentframe().f_code.co_name,
                inspect.currentframe().f_lineno,
                '"' + str(peer) + '"' +
                ' appears to be an IP network, leaving')
            return str(peer_ip)

    else:
        print_debug(debug, inspect.currentframe().f_code.co_name,
            inspect.currentframe().f_lineno,
            '"' + str(peer_ip) + '"' + ' appears to be an IP address, leaving')
        return str(peer_ip)

    raise ValueError("Participant " + peer + " not valid.") from Exception

def make_config(args, my_config):
    """ Make the configuration from argparse arguments

        args        - argparse arguments
        my_config   - program configuration dictionary

     Returns a dictionary with the connection configuration properties
    """

    debug = my_config['debug']

    print_debug(debug, inspect.currentframe().f_code.co_name,
        inspect.currentframe().f_lineno,
        'entered')

    # The connection configuration dictionary we're going to return
    conn_config = {}

    # Connection name
    conn_config['name'] = args.name.strip()

    # Connection type
    conntype = ''
    types = ['transport', 'tunnel', 'passthrough', 'drop', 'reject']

    if args.type is not None:
        conntype = str(args.type).strip().lower()
    else:
        print_debug(debug, inspect.currentframe().f_code.co_name,
            inspect.currentframe().f_lineno, 'connection type not defined, '
                                             + 'skipping')

    if conntype:
        if conntype in types:
            conn_config['type'] = conntype
        else:
            separator = ', '
            fatal_error('Invalid connection type "' + str(args.type).strip()
                        + '".\nAccepted values are: '
                        + separator.join(types)+ '\n')

    # Left participant
    try:
        conn_config['left'] = args.left.strip()
        conn_config['left'] = get_peer_confstring(conn_config['left'], my_config)
    except ValueError:
        fatal_error('Left participant "' + args.left.strip() +
                    '" is not valid.')

    # Right participant
    try:
        conn_config['right'] = args.right.strip()
        conn_config['right'] = get_peer_confstring(conn_config['right'], my_config)
    except ValueError:
        fatal_error('Right participant "' + args.right.strip() +
                    '" is not valid.')

    print_debug(debug, inspect.currentframe().f_code.co_name,
        inspect.currentframe().f_lineno, 'leaving')

    return conn_config

def main():
    """ The main program """

    parser = argparse.ArgumentParser(description='Create new connection \
                                                  configuration file',
                                     add_help=False,
                                     allow_abbrev=True)

    opts1 = parser.add_argument_group('Connection general parameters')
    opts1.add_argument('-n', '--name',
                            required=True,
                            help='connection name')
    opts1.add_argument('-t', '--type',
                            help='type of connection {tunnel|transport|'
                               + 'passthrough|drop|reject}')
    opts1.add_argument('--auto',
                            help='operation to do at IPsec startup {add|start|'
                                + 'ignore|ondemand}')

    opts2 = parser.add_argument_group('Protocol options')

    ike_version = opts2.add_mutually_exclusive_group()
    ike_version.add_argument('-v1', '--ikev1',
                                action='store_true',
                                help='use IKEv1')
    ike_version.add_argument('-v2', '--ikev2',
                                action='store_true',
                                help='use IKEv2 (default)')

    # opts2.add_argument('-encap', '--encapsulate',
    #                        help='optionally, force ESP/AH encapsulation \
    #                              inside UDP/TCP (NAT-T) {yes|no|auto}',
    #                        action='store_true')

    opts3 = parser.add_argument_group('Authentication/keying parameters')
    authby = opts3.add_mutually_exclusive_group()
    authby.add_argument('-a', '--authby',
                            help='authentication {rsasig|rsa-sha2|rsa-sha2_384|'
                                + 'rsa-sha2_512|secret|secret-rsasig|'
                                + 'never|null}')
#    asynauth = authby.add_mutually_exclusive_group()
#    asynauth.add_argument('-la', '--leftauth',
#                                help='IKEv2 asymmetric authentication of \
#                                the left peer')
#    asynauth.add_argument('-ra', '--rightauth',
#                                help='IKEv2 asymmetric authentication of \
#                                the right peer')

    opts3.add_argument('--ike',
                            help='IKE encryption and authentication algorithms\
                                 "cipher-hash;modpgroup", use multiple times \
                                  to add more than one set',
                            action='append')
    opts3.add_argument('--esp',
                            help='algorithms offered/accepted for \
                                IPsec child SAs (phase 2) \
                                "ENC-AUTH-PFSgroup", use multiple times to \
                                add more than one set',
                            action='append')
    opts3.add_argument('--nopfs',
                            help='disable Perfect Forward Secrecy of keys',
                            action='store_true')

    opts3.add_argument('--sendca',
                            help='optionally, how many intermediate CA \
                                  certificate levels to send with the end \
                                  certificate {none|issuer|all}')

    leftopts = parser.add_argument_group('Left participant\'s specific options')

    leftopts.add_argument('-l', '--left',
                            help='IP address or DNS hostname of the left peer \
                                  (e.g. public address of the local host)',
                            required=True)
    leftopts.add_argument('-lid', '--leftid',
                            help='identification of the left peer')
    leftopts.add_argument('-lnet', '--leftsubnet',
                            help='private subnet(s) behind the left peer \
                                 in CIDR notation, use multiple times \
                                 to define multiple private subnets',
                            action='append')
    leftopts.add_argument('-lcert', '--leftcert',
                            help='certificate nickname of the left peer')

    rightopts = parser.add_argument_group('Right participant\'s specific'
                                         + ' options')

    rightopts.add_argument('-r', '--right',
                            help='IP address or DNS hostname of the right peer \
                                  (e.g. public address of the remote host)',
                            required=True)
    rightopts.add_argument('-rid', '--rightid',
                            help='identification of the right peer')
    rightopts.add_argument('-rnet', '--rightsubnet',
                            help='private subnet behind the right peer \
                                 in CIDR notation, use multiple times \
                                 to define multiple private subnets',
                            action='append')
    rightopts.add_argument('-rcert', '--rightcert',
                            help='certificate nickname of the right peer')

    other = parser.add_argument_group('Other options')
    other.add_argument('-h', '--help',
                            action='help',
                            help='show this help message and exit')
    other.add_argument('-v', '--version',
                            action='store_true',
                            help='show version and exit')
    ask = other.add_mutually_exclusive_group()
    ask.add_argument('-i', '--interactive',
                            action='store_true',
                            help='ask the user if needed')
    ask.add_argument('-y', '--yes',
                            action='store_true',
                            help='assume "yes" to all possible questions')
    other.add_argument('-d', '--debug',
                            action='store_true',
                            help='show debugging')
    other.add_argument('--nodns',
                            action='store_true',
                            help='do not validate values using DNS resolution')

    args = parser.parse_args()

    # Done parsing arguments, use them now.

    # Program configuration dictionary
    my_config = {
        'debug': args.debug,
        'prompt': args.interactive,
        'assume_yes': args.yes,
        'dns': not args.nodns
    }

    if args.version:
        print("version: 0.1")
        sys.exit(0)

    # Make the config from arguments
    conn_config = make_config(args, my_config)

    print(conn_config)

    print("conn " + conn_config['name'])

    # This maybe should be inside a function? XXX
    config_fname = CONFDIR + '/' + conn_config['name'].strip()
    write_config(config_fname, my_config)

    print_debug(my_config['debug'], inspect.currentframe().f_code.co_name,
        inspect.currentframe().f_lineno,
        'done.')

# We start here

if __name__ == "__main__":
    main()
